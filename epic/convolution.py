from __future__ import division
import bisect
import numpy as np
from numpy.lib.stride_tricks import as_strided
try:
    # FFTW3 Wrapper
    import pyfftw.interfaces.numpy_fft as fft
except ImportError:
    # Numpy FFT
    import numpy.fft as fft


# ----------------------------------------------------------------------------
# Windows
# ----------------------------------------------------------------------------
def windows(x, shape):
    """Return all valid windows in a MxNx... signal with spatial shape

    This simply restrides the array so that no copies are performed.

    Args:
        x: An ndarray with at least two dimensions MxN. Other trailing dimensions
            are assumed to be channels
        shape: The PxQ spatial shape of the windows to retrive

    Returns:
        An array with shape (M-P+1,N-Q+1,P,Q,...)
    """
    # compute the input and filter shape
    Mx,Nx = x.shape[:2]
    Mg,Ng = shape[:2]
    K,B   = np.prod(x.shape[2:]), x.itemsize

    # compute the output shape and strides
    shape = (Mx-Mg+1,Nx-Ng+1,Mg,Ng)+x.shape[2:]
    strides = (Nx*K*B,K*B,Nx*K*B,K*B)+x.strides[2:]

    # restride the array
    return as_strided(x, shape=shape, strides=strides)


# ----------------------------------------------------------------------------
# Gemm
# ----------------------------------------------------------------------------
def gemm(g, x, mean, covinv, padding=None):
    """Construct a detector and compute the correlation between all pairs of pixels

    The convolution is performed by explicitly constructing matrices from all
    patches and then computing the gemm:

        covinv.dot(g.T).T.dot(x.T)

    Args:
        g: The feature image to build detectors from
        x: The feature image to convolve with
        mean: The mean negative image
        covinv: The inverse covariance matrix (or proxy) generated by lda.inverse

    Keyword Args:
        padding: By default, valid convolution is performed. If padding is one
            of 'constant', 'reflect', or 'edge' (see np.pad), then the inputs
            are padded such that the output is the same size as the inputs. This
            can be useful, since it produces a full set of responses, even though
            some may be influenced heavily by boundary effects.
    """

    # infer the filter size
    K = mean.size
    Mw, Nw = np.sqrt(np.array(covinv.shape) / K)
    Mh, Nh = np.floor((Mw/2, Nw/2))

    # pad the inputs if requested
    if padding:
        x = np.pad(x, ((Mh,Mh), (Nh,Nh), (0,0)), mode=padding)
        g = np.pad(g, ((Mh,Mh), (Nh,Nh), (0,0)), mode=padding)

    # get the image sizes
    Mx, Nx = x.shape[:2]
    Mg, Ng = g.shape[:2]

    # stride the input arrays into the matrix of patches
    mean = mean.reshape(1,1,K)
    xs = windows(x-mean, (Mw, Nw))
    gs = windows(g-mean, (Mw, Nw))

    # reshape them into multiplible matrices (forces a copy)
    gs = gs.reshape(-1,Mw*Nw*K)
    xs = xs.reshape(-1,Mw*Nw*K)

    # compute the gemm convolution
    return covinv.dot(gs.T).T.dot(xs.T).reshape(Mg-Mw+1,Ng-Nw+1,Mx-Mw+1,Nx-Nw+1)


# ----------------------------------------------------------------------------
# FFT
# ----------------------------------------------------------------------------
def optimal_fft_size(*shape):
    """Compute the optimal FFT size for a given shape using a LUT heuristic"""
    lut = [8, 16, 32, 52, 64, 88, 108, 128, 180, 256, 300, 384, 512, 768, 1024]
    index = (bisect.bisect_left(lut, n) for n in shape)
    return tuple(lut[m] if m < len(lut) else n for m,n in zip(index,shape))

def construct_fft_lut(repeat=5, base=1000, N=1024):
    """Construct a LUT of the optimal transform sizes for this architecture

    Rather than rely on heuristics, this function brute-force searches all
    FFT sizes up to 1024 and records the minimum time sizes.

    THE LOOKUP TABLE CAN TAKE A LONG TIME TO CONSTRUCT!

    Keyword Args:
        repeat: The number of repeats to average
        base: The base number of runs to perform (modified by the actual dft size)
        N: The maximum DFT size to consider

    Returns:
        lut: The lookup table of optimal transform sizes for 0 < x < N+1
    """
    import timeit

    time, argmin = [], [N]
    setup = 'from epic.convolution import fft; import numpy; x = numpy.random.standard_normal({n});'
    for n in range(N,1,-1):
        # compute the time over multiple runs
        number = int(base/(np.log2(n)))
        times = timeit.repeat(stmt='fft.rfft(x)', setup=setup.format(n=n),
            repeat=repeat, number=number)
        # get the minimum time (eliminates context-switching cost)
        time.append( min(times) / number )

    # compute the lower envelope
    for n in range(N-1):
        if time[n] < time[N-argmin[0]]:
            argmin.insert(0,N-n)

    # return the LUT
    return argmin
