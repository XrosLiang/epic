from __future__ import division
import bisect
import numpy as np
from numpy.lib.stride_tricks import as_strided
try:
    # FFTW3 Wrapper
    import pyfftw.interfaces.numpy_fft as fft
except NameError:
    # Numpy FFT
    import numpy.fft as fft


# ----------------------------------------------------------------------------
# Gemm
# ----------------------------------------------------------------------------
def gemm(g, x, mean, covinv, padding=None):
    """Construct a detector and compute the correlation between all pairs of pixels

    The convolution is performed by explicitly constructing matrices from all
    patches and then computing the gemm:

        covinv.dot(g.T).T.dot(x.T)

    Args:
        g: The feature image to build detectors from
        x: The feature image to convolve with
        mean: The mean negative image
        covinv: The inverse covariance matrix (or proxy) generated by lda.inverse

    Keyword Args:
        padding: By default, valid convolution is performed. If padding is one
            of 'constant', 'reflect', or 'edge' (see np.pad), then the inputs
            are padded such that the output is the same size as the inputs. This
            can be useful, since it produces a full set of responses, even though
            some may be influenced heavily by boundary effects.
    """

    # infer the filter size
    K = mean.size
    Mw, Nw = np.sqrt(np.array(covinv.shape) / K)
    Mh, Nh = np.floor((Mw/2, Nw/2))

    # pad the inputs if requested
    if padding:
        x = np.pad(x, ((Mh,Mh), (Nh,Nh), (0,0)), mode=padding)
        g = np.pad(g, ((Mh,Mh), (Nh,Nh), (0,0)), mode=padding)

    # get the image sizes
    (Mx,Nx),Bx = x.shape[:2], x.dtype.itemsize
    (Mg,Ng),Bg = g.shape[:2], g.dtype.itemsize

    # stride the input arrays into the matrix of patches
    mean = mean.reshape(1,1,K)
    xs = as_strided(x-mean, shape=(Mx-Mw+1,Nx-Nw+1,Mw,Nw,K), strides=(Nx*K*Bx,K*Bx,Nx*K*Bx,K*Bx,Bx))
    gs = as_strided(g-mean, shape=(Mg-Mw+1,Ng-Nw+1,Mw,Nw,K), strides=(Ng*K*Bg,K*Bg,Ng*K*Bg,K*Bg,Bg))

    # reshape them into multiplible matrices (forces a copy)
    gs = gs.reshape(-1,Mw*Nw*K)
    xs = xs.reshape(-1,Mw*Nw*K)

    # compute the gemm convolution
    return covinv.dot(gs.T).T.dot(xs.T).reshape(Mg-Mw+1,Ng-Nw+1,Mx-Mw+1,Nx-Nw+1)


# ----------------------------------------------------------------------------
# FFT
# ----------------------------------------------------------------------------
def optimal_fft_size(*shape):
    """Compute the optimal FFT size for a given shape using a LUT heuristic"""
    lut = [8, 16, 32, 52, 64, 88, 108, 128, 180, 256, 300, 384, 512, 768, 1024]
    index = (bisect.bisect_left(lut, n) for n in shape)
    return tuple(lut[m] if m < len(lut) else n for m,n in zip(index,shape))

def construct_fft_lut(repeat=5, base=1000, N=1024):
    """Construct a LUT of the optimal transform sizes for this architecture

    Rather than rely on heuristics, this function brute-force searches all
    FFT sizes up to 1024 and records the minimum time sizes. If this file
    is writeable, it also overwrites the ``optimal_fft_size`` function with
    the lookup table.

    THE LOOKUP TABLE CAN TAKE A LONG TIME TO CONSTRUCT!

    Returns:
        lut: The lookup table of optimal transform sizes for 0 < x < N+1
    """
    import re
    import sys
    import inspect
    import timeit

    time, argmin = [], [N]
    setup = 'from epic.convolution import fft; import numpy; x = numpy.random.standard_normal(({n},));'
    for n in range(N,1,-1):
        # compute the time over multiple runs
        number = int(base/(np.log2(n)))
        times = timeit.repeat(stmt='fft.rfft(x)', setup=setup.format(n=n),
            repeat=repeat, number=number)
        # get the minimum time (eliminates context-switching cost)
        time.append( min(times) / number )

    # compute the lower envelope
    for n in range(N-1):
        if time[n] < time[N-argmin[0]]:
            argmin.insert(0,N-n)

    # replace the optimal_fft_size function
    try:
        module = inspect.getsource(sys.modules[__name__])
        oldlut = inspect.getsource(optimal_fft_size)
        newlut = 'lut = {}'.format(str(argmin))
        newlut = re.sub(r'lut = \[[^\]]*\]', newlut, oldlut)
        with open(__file__, 'w') as f:
            f.write(module.replace(oldlut, newlut))
    except:
        pass

    # return the LUT
    return argmin
